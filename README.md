# Leveraging glibc in exploitation
This repository contains an example vulnerable program named "big-roi" (Bad
Insecure Grotesquely Really Obviously Insecure) server. This example program
is part of my "Leveraging glibc in exploitation" blog series. It demonstrates
not only how glibc can be used in an exploit, but also how modern-ish exploit
mitigations can be bypassed. This example may make good practice for other
basic binary exploitation strategies - so feel free to use it as a learning
tool if you like.

In addition, this repository contains automation that demonstrates how to
exploit the vulnerable program.

Note: big-roi was developed on a Ubuntu 20.04 machine. I recommend using
that OS when running big-roi because many glibc fingerprinting tools
only know about Debian or Ubuntu glibc binaries.

For more information, please refer to the
[companion blog post series](https://control.rip/posts/2022/08/16/leveraging-glibc-in-exploitation-p1/).

## Included files

- `big-roi` - The example program in compiled, executable form
- `big-roi.c` - The example program's source code
- `big-roi.objdump.txt` - The example program's `objdump` disassembly. This can
  be used to quasi-authenticate the included executable by checking it against
  your own `objdump` output (created using: `objdump -D -M intel big-roi`)
- `cmd/` - A directory containing Go programs that automate exploitation of the
  example program (requires the Go / Golang compiler)

## The scenario
In this imaginary scenario, a developer was experimenting with implementing
a lightweight file server for Linux-based OSes with optional password
protection. In the process of attaining "high ROI and velocity", they
implemented an application with some significant security challenges.

It is your job to bypass the program's password authentication, ideally by
using code from glibc.

## Usage
Once compiled, the application takes two arguments: a TCP port to listen on,
and a file to share. The user can optionally set a password by first generating
a bcrypt password string, and then setting an environment variable equal to
the bcrypt string. For example:

```sh
# Note: This requires openssl.
# Refer to "man openssl-passwd" for more information.
$ export PASSWORD_BCRYPT=$(openssl passwd -5)
# <Type in a password and confirm it>
$ echo 'keith says to forget about it!' > /tmp/secret-data
$ ./big-roi 6666 /tmp/secret-data
```

Users can retrieve the file by connecting to the process over TCP and sending
a password:

```sh
# Note: Make sure to not include a trailing new line character.
$ printf '%s' 'gfy' | nc 127.0.0.1 6666
incorrect password: gfy
$ printf '%s' '<actual password>' | nc 127.0.0.1 6666
keith says to forget about it!
```

## Compiling
If you are following along with the blog series, I recommend using the included
executable. Compiling from source may change attributes about the program that
make it deviate from what I describe in the blog posts.

In my series, I used a Ubuntu 20.04 Docker container as the build and
exploit environment. The program can be compiled by running:

```sh
# apt install gcc
$ gcc -o /tmp/big-roi -g big-roi.c -lcrypt
```
